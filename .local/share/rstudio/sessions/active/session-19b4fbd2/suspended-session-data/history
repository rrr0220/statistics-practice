rho_upper = tanh(z + stats::qnorm(0.025, lower.tail=FALSE) / sqrt(length(df$x)-3))
stats::cor.test(df$x, df$y)
tbl = matrix(c(10, 20, 20, 30, 10, 10), nrow=2, ncol=3)
tbl
?matrix
tbl = matrix(c(10, 20, 20, 30, 10, 10), nrow=2, ncol=3, byrow=TRUE)
tbl
tbl = matrix(c(10, 20, 20, 30, 10, 10), nrow=2, ncol=3, byrow=TRUE,
colnames=c("A", "B", "C"))
tbl = matrix(c(10, 20, 20, 30, 10, 10), nrow=2, ncol=3, byrow=TRUE)
colnames(tbl) = c("A", "B", "C")
tbl
tbl
chisq.test(tbl, correct=FALSE)
rownames(tbl) = c(1, 2)
tbl
rownames(tbl) = c("1", "2")
tbl
chisq.test(tbl, correct=FALSE)
soudosu = sum(tbl)
soudosu
?sumrow
?sumRow
?sumRows
syuhendosu_row = rowSums(tbl)
syuhendosu_row
soudosu
syuhendosu_colum = colSums(tbl)
syuhendosu_column = colSums(tbl)
syuhendosu_column
tbl = matrix(c(10, 20, 20, 30, 10, 10), nrow=2, ncol=3, byrow=TRUE)
colnames(tbl) = c("A", "B", "C")
rownames(tbl) = c("1", "2")
tbl
chisq.test(tbl, correct=FALSE)
total_freq = sum(tbl)
marginal_freq_row = rowSums(tbl)
marginal_freq_column = colSums(tbl)
marginal_freq_row
marginal_freq_column
total_freq
marginal_freq_row[1]
marginal_freq_row[1] * marginal_freq_column[1]
marginal_freq_row[1] * marginal_freq_column[1] / total_freq
i = 1
marginal_freq_row[i] * marginal_freq_column[i] / total_freq
i = 1
j = 1
marginal_freq_row[i] * marginal_freq_column[j] / total_freq
vec = c()
expected_freq = marginal_freq_row[i] * marginal_freq_column[j] / total_freq
append(vec, expected_freq)
vec = append(vec, expected_freq)
for (i in 1:2){
for (j in 1:3){
vec = c()
expected_freq = marginal_freq_row[i] * marginal_freq_column[j] / total_freq
vec = append(vec, expected_freq)
}
}
vec
vec = c()
for (i in 1:2){
for (j in 1:3){
expected_freq = marginal_freq_row[i] * marginal_freq_column[j] / total_freq
vec = append(vec, expected_freq)
}
}
vec
marginal_freq_column
tbl_expected = matrix(vec, nrow=2, ncol=3, byrow=TRUE)
tbl_expected
rm(i, j, vec)
# カイ二乗要素の計算
tbl_chisq = (tbl - tbl_expected)^2 / tbl_expected
tbl_chisq
# χ^2_0の計算
chisq0 = sum(tbl_chisq)
chisq0
# 指定した下側・上側確率に対応するχ^2値（境界値）
stats::qchisq(0.025, df=length(data)-1)
# 指定した下側・上側確率に対応するχ^2値（境界値）
stats::qchisq(0.025, df=nrow(tbl)*ncol(tbl))
stats::qchisq(0.025, df=nrow(tbl)*ncol(tbl), lower.tail=FALSE)
# 描画
graphics::par(new=TRUE)
graphics::curve(dchisq(x, df=nrow(tbl)*ncol(tbl), from=0, to=30)
graphics::curve(dchisq(x, df=nrow(tbl)*ncol(tbl)), from=0, to=30)
graphics::curve(dchisq(x, df=nrow(tbl)*ncol(tbl)), from=0, to=30)
graphics::abline(v=chisq0, col="blue")
graphics::abline(v=stats::qchisq(0.025, df=nrow(tbl)*ncol(tbl)), col="red")
graphics::abline(v=stats::qchisq(0.025, df=nrow(tbl)*ncol(tbl), lower.tail=FALSE), col="red")
stats::qchisq(0.05, df=nrow(tbl)*ncol(tbl), lower.tail=FALSE)
graphics::abline(v=stats::qchisq(0.05, df=nrow(tbl)*ncol(tbl), lower.tail=FALSE), col="red")
# 描画
graphics::par(new=TRUE)
graphics::curve(dchisq(x, df=nrow(tbl)*ncol(tbl)), from=0, to=30)
graphics::curve(dchisq(x, df=nrow(tbl)*ncol(tbl)), from=0, to=30)
graphics::abline(v=chisq0, col="blue")
graphics::abline(v=stats::qchisq(0.05, df=nrow(tbl)*ncol(tbl), lower.tail=FALSE), col="red")
chisq.test(tbl, correct=FALSE)
# 指定した上側確率に対応するχ^2値（境界値）
stats::qchisq(0.05, df=(nrow(tbl)-1)*(ncol(tbl)-1), lower.tail=FALSE)
# 描画
graphics::par(new=TRUE)
graphics::curve(dchisq(x, df=(nrow(tbl)-1)*(ncol(tbl)-1), from=0, to=30)
graphics::curve(dchisq(x, df=(nrow(tbl)-1)*(ncol(tbl)-1), from=0, to=30)
graphics::curve(dchisq(x, df=(nrow(tbl)-1)*(ncol(tbl)-1)), from=0, to=30)
graphics::curve(dchisq(x, df=(nrow(tbl)-1)*(ncol(tbl)-1)), from=0, to=30)
graphics::abline(v=chisq0, col="blue")
graphics::abline(v=stats::qchisq(0.05, df=nrow(nrow(tbl)-1)*(ncol(tbl)-1), lower.tail=FALSE), col="red")
# 指定した上側確率に対応するχ^2値（境界値）
stats::qchisq(0.05, df=(nrow(tbl)-1)*(ncol(tbl)-1), lower.tail=FALSE)
graphics::abline(v=stats::qchisq(0.05, df=nrow(nrow(tbl)-1)*(ncol(tbl)-1), lower.tail=FALSE), col="red")
graphics::abline(v=stats::qchisq(0.05, df=(nrow(tbl)-1)*(ncol(tbl)-1), lower.tail=FALSE), col="red")
graphics::curve(dchisq(x, df=(nrow(tbl)-1)*(ncol(tbl)-1)), from=0, to=30)
graphics::abline(v=chisq0, col="blue")
graphics::abline(v=stats::qchisq(0.05, df=(nrow(tbl)-1)*(ncol(tbl)-1), lower.tail=FALSE), col="red")
# クラメールの連関係数の計算
library(vcd)
?vcd
??vcd
vcd::assocstats(tbl)
# V = sqrt(χ^2/(min(a, b)-1)*N)
V = sqrt(chisq0/((min(nrow(tbl), ncol(tbl))-1) * total_freq))
V
# 指定した上側確率に対応するχ^2値（境界値）
stats::qchisq(0.05, df=(nrow(tbl)-1)*(ncol(tbl)-1), lower.tail=FALSE)
A1 = c(4, 5, 3)
A2 = c(6, 8, 6, 7, 8)
A3 = c(2, 3, 3, 2)
A1_sum = sum(A1)
sum(A1)
sum(A2)
sum(A3)
ave(A1)
mean(A1)
mean(A2)
mean(A3)
sqrt(sum((A1-mean(A1))^2)/length(A1))
sqrt(sum((A2-mean(A2))^2)/length(A2))
sqrt(sum((A3-mean(A3))^2)/length(A3))
sum(sum(A1), sum(A2), sum(A3))
sum(sum(A1), sum(A2), sum(A3))/sum(length(A1), length(A2), length(A3))
A1_sd = sqrt(sum((A1-mean(A1))^2)/length(A1))
A2_sd = sqrt(sum((A2-mean(A2))^2)/length(A2))
A3_sd = sqrt(sum((A3-mean(A3))^2)/length(A3))
T = sum(sum(A1), sum(A2), sum(A3))
T_ave = sum(sum(A1), sum(A2), sum(A3))/sum(length(A1), length(A2), length(A3))
SA = sum(length(A1)*((mean(A1)-T_ave)^2),
length(A2)*((mean(A2)-T_ave)^2),
length(A3)*((mean(A3)-T_ave)^2))
SE = sum(sum((A1-mean(A1))^2), sum((A2-mean(A2))^2), sum((A3-mean(A3))^2))
ST = sum(sum((A1-T_ave)^2), sum((A2-T_ave)^2), sum((A3-T_ave)^2))
ST
SE
SA
dfA =
dfE =
dfT = T - 1
dfT = T - 1
dfT = sum(length(A1), length(A2), length(A3) - 1
dfT = sum(length(A1), length(A2), length(A3) - 1
dfA =
dfE =
dfT = sum(length(A1), length(A2), length(A3)) - 1
dfT = sum(length(A1), length(A2), length(A3)) - 1
dfA = 3 - 1
dfE = sum(length(A1), length(A2), length(A3)) - 3
names(A1) = A1
A1
names(A1) = "A1"
A1
A1 = c(4, 5, 3)
A2 = c(6, 8, 6, 7, 8)
A3 = c(2, 3, 3, 2)
A1
A2
A3
list(A1=A1, A2=A2, A3=A3)
A_list = list(A1=A1, A2=A2, A3=A3)
A_list
data_list = list(A1=A1, A2=A2, A3=A3)
data_list
VA = SA/dfA
VA
VE = SE/dfE
F0 = VA/VE
sd = c(A1_sd, A2_sd, A3_sd)
sd
data_list
names(sd) = c("A1_sd", "A2_sd", "A3_sd")
sd
A1 = c(4, 5, 3)
A2 = c(6, 8, 6, 7, 8)
A3 = c(2, 3, 3, 2)
data_list = list(A1=A1, A2=A2, A3=A3)
T_ave = sum(sum(A1), sum(A2), sum(A3))/sum(length(A1), length(A2), length(A3))
SA = sum(length(A1)*((mean(A1)-T_ave)^2),
length(A2)*((mean(A2)-T_ave)^2),
length(A3)*((mean(A3)-T_ave)^2))
SE = sum(sum((A1-mean(A1))^2), sum((A2-mean(A2))^2), sum((A3-mean(A3))^2))
ST = sum(sum((A1-T_ave)^2), sum((A2-T_ave)^2), sum((A3-T_ave)^2))
SS_vec = c(SA, SE, ST)
SS_vec
names(SS_vec) = c("SA", "SE", "ST")
SS_vec
DF_vec = c(dfA, dfE, dfT)
dfA = 3 - 1
dfE = sum(length(A1), length(A2), length(A3)) - 3
dfT = sum(length(A1), length(A2), length(A3)) - 1
DF_vec = c(dfA, dfE, dfT)
names(DF_vec) = c("DFA", "DFE", "DFT")
DF_vec
VAR_vec = c(VA, VE)
VA = SA/dfA
VE = SE/dfE
VAR_vec = c(VA, VE)
Var_vec = c(VA, VE)
names(Var_vec) = c("VA", "VE")
names(Var_vec) = c("VarA", "VarE")
Var_vec
A1 = c(4, 5, 3)
A2 = c(6, 8, 6, 7, 8)
A3 = c(2, 3, 3, 2)
data_list = list(A1=A1, A2=A2, A3=A3)
data_list
T_ave = sum(sum(A1), sum(A2), sum(A3))/sum(length(A1), length(A2), length(A3))
SA = sum(length(A1)*((mean(A1)-T_ave)^2),
length(A2)*((mean(A2)-T_ave)^2),
length(A3)*((mean(A3)-T_ave)^2))
SE = sum(sum((A1-mean(A1))^2), sum((A2-mean(A2))^2), sum((A3-mean(A3))^2))
ST = sum(sum((A1-T_ave)^2), sum((A2-T_ave)^2), sum((A3-T_ave)^2))
SS_vec = c(SA, SE, ST)
names(SS_vec) = c("SA", "SE", "ST")
SS_vec
dfA = 3 - 1
dfE = sum(length(A1), length(A2), length(A3)) - 3
dfT = sum(length(A1), length(A2), length(A3)) - 1
DF_vec = c(dfA, dfE, dfT)
names(DF_vec) = c("DFA", "DFE", "DFT")
DF_vec
VA = SA/dfA
VE = SE/dfE
Var_vec = c(VA, VE)
names(Var_vec) = c("VarA", "VarE")
Var_vec
F0 = VA/VE
ANOVA_list = list(data=data_list, sum_of_squares=SS_vec, degree_of_freedom=DF_vec, varience=Var_vec, F0=F0)
ANOVA_list = list(data=data_list, sum_of_squares=SS_vec,
degree_of_freedom=DF_vec, varience=Var_vec, F0=F0)
ANOVA_list
# 指定した上側確率に対応するF値（境界値）
stats::qf(0.05, df1=2, df2=9, lower.tail=FALSE)
# 描画
graphics::par(new=TRUE)
graphics::curve(df(x, df1=2, df2=9), from=0, to=30)
graphics::curve(df(x, df1=2, df2=9), from=0, to=30)
graphics::abline(v=F0, col="blue")
graphics::curve(df(x, df1=2, df2=9), from=0, to=40)
graphics::abline(v=F0, col="blue")
graphics::abline(v=stats::qf(0.05, df1=2, df2=9, lower.tail=FALSE), col="red")
graphics::curve(df(x, df1=2, df2=9), from=0, to=35)
graphics::abline(v=F0, col="blue")
graphics::abline(v=stats::qf(0.05, df1=2, df2=9, lower.tail=FALSE), col="red")
ANOVA_list
ANOVA_list = list(data=data_list, sum_of_squares=SS_vec,
degree_of_freedom=DF_vec, variance=Var_vec, F0=F0)
ANOVA_list
rm(A1, A2, A3, data_list, T_ave, SA, SE, ST, SS_vec, dfA, dfE, dfT, DF_vec, VA, VE, Var_vec)
ANOVA_list
ANOVA_list[1]
ANOVA_list[2]
ANOVA_list[3]
ANOVA_list[1][1]
ANOVA_list[[1]]
ANOVA_list[1][1]
ANOVA_list[1][[1]]
ANOVA_list[2]
ANOVA_list$sum_of_squares
ANOVA_list$sum_of_squares$SA
ANOVA_list$sum_of_squares[1]
ANOVA_list[1][1]
ANOVA_list[2][1]
ANOVA_list[[2]][1]
ANOVA_list[[2]]
ANOVA_list[[2]][2]
knitr::opts_chunk$set(echo = TRUE)
?sd
mu_lower
# 母数の95％信頼区間の計算
(mu_lower = mean(x) - stats::qt(0.025, df=length(x)-1, lower.tail=FALSE) * sqrt(stats::sd(x)/length(x)))
# 母数の95％信頼区間の計算
(mu_lower = mean(x) - stats::qt(0.025, df=length(x)-1, lower.tail=FALSE) * sqrt(stats::sd(x)/length(x)))
# 母数の95％信頼区間の計算
(mu_lower = mean(x) - stats::qt(0.025, df=length(x)-1, lower.tail=FALSE) * sqrt(stats::sd(x)/length(x)))
# 母数の95％信頼区間の計算
(mu_lower = mean(x) - stats::qt(0.025, df=length(x)-1, lower.tail=FALSE) * sqrt(stats::sd(x)/length(x)))
# データ準備
x = c(3, 4, 2, 9, 6, 7, 5, 6, 5, 4)
# t0の計算
(t0 = (mean(x)-3)/sqrt(stats::sd(x)/length(x)))
# 上側確率2.5%に対応するt値(境界線)
stats::qt(0.025, df=length(x)-1, lower.tail=FALSE)
# 下側確率2.5%に対応するt値(境界線)
stats::qt(0.025, df=length(x)-1)
# 母数の95％信頼区間の計算
(mu_lower = mean(x) - stats::qt(0.025, df=length(x)-1, lower.tail=FALSE) * sqrt(stats::sd(x)/length(x)))
(mu_upper = mean(x) + stats::qt(0.025, df=length(x)-1, lower.tail=FALSE) * sqrt(stats::sd(x)/length(x)))
# t0の計算
(t0 = (mean(x)-3)/stats::sd(x)/sqrt(length(x)))
# 上側確率2.5%に対応するt値(境界線)
stats::qt(0.025, df=length(x)-1, lower.tail=FALSE)
# 下側確率2.5%に対応するt値(境界線)
stats::qt(0.025, df=length(x)-1)
graphics::par(new=TRUE)
graphics::curve(dt(x, df=length(x)-1), from=-5, to=5)
graphics::abline(v=t0, col="blue")
graphics::abline(v=stats::qt(0.025, df=length(x)-1, lower.tail=FALSE), col="red")
graphics::abline(v=stats::qt(0.025, df=length(x)-1), col="red")
# 母数の95％信頼区間の計算
(mu_lower = mean(x) - stats::qt(0.025, df=length(x)-1, lower.tail=FALSE) * sqrt(stats::sd(x)/length(x)))
(mu_upper = mean(x) + stats::qt(0.025, df=length(x)-1, lower.tail=FALSE) * sqrt(stats::sd(x)/length(x)))
# 母数の95％信頼区間の計算
(mu_lower = mean(x) - stats::qt(0.025, df=length(x)-1, lower.tail=FALSE) * stats::sd(x)/sqrt(length(x)))
(mu_upper = mean(x) + stats::qt(0.025, df=length(x)-1, lower.tail=FALSE) * stats::sd(x)/sqrt(length(x)))
# 母数の95％信頼区間の計算
(mu_lower = mean(x) - stats::qt(0.025, df=length(x)-1, lower.tail=FALSE) * stats::sd(x)/sqrt(length(x)))
(mu_upper = mean(x) + stats::qt(0.025, df=length(x)-1, lower.tail=FALSE) * stats::sd(x)/sqrt(length(x)))
# 上側確率2.5%に対応するt値(境界線)
stats::qt(0.025, df=length(x)-1, lower.tail=FALSE)
# 下側確率2.5%に対応するt値(境界線)
stats::qt(0.025, df=length(x)-1)
# t0の計算
(t0 = (mean(x)-3)/(stats::sd(x)/sqrt(length(x)))
# t0の計算
(t0 = (mean(x)-3)/(stats::sd(x)/sqrt(length(x))))
# t0の計算
(t0 = (mean(x)-3)/(stats::sd(x)/sqrt(length(x))))
# t0の計算
(t0 = (mean(x)-3)/(stats::sd(x)/sqrt(length(x))))
# t0の計算
(t0 = (mean(x)-3)/(stats::sd(x)/sqrt(length(x))))
# t0の計算
(t0 = (mean(x)-3)/(stats::sd(x)/sqrt(length(x))))
# t0の計算
(t0 = (mean(x)-3)/(stats::sd(x)/sqrt(length(x))))
(t0 = (mean(x)-3)/(stats::sd(x)/sqrt(length(x))))
# t0の計算
(t0 = (mean(x)-3)/(stats::sd(x)/sqrt(length(x))))
A = matrix(c(3, 1, 2, 2), nrow=2, ncol=2, byrow=TRUE)
A
B = matrix(c(4, 2, 8, 5), nrow=2, ncol=2, byrow=TRUE)
B
C = matrix(c(1, 2, 2, 4), nrow=2, ncol=2, byrow=TRUE)
C
AB = A %*% B
AB
AB^T = t(AB)
ABT = t(AB)
ABT
AB_t = t(AB)
A_t = t(A)
A_t
A
B_t = t(B)
B_t
B_t*A_t = B_t %*% A_t
B_t_A_t = B_t %*% A_t
B_t_A_t
A = matrix(c(3, 1, 2, 2), nrow=2, ncol=2, byrow=TRUE)
B = matrix(c(4, 2, 8, 5), nrow=2, ncol=2, byrow=TRUE)
C = matrix(c(1, 2, 2, 4), nrow=2, ncol=2, byrow=TRUE)
AB = A %*% B
ABt = t(AB)
At = t(A)
Bt = t(B)
BtAt = B_t %*% A_t
BtAt = Bt %*% At
identical(ABt, BtAt)
solve(AB)
det(AB)
AB-1 =solve(AB)
AB.inv =solve(AB)
A = matrix(c(3, 1, 2, 2), nrow=2, ncol=2, byrow=TRUE)
B = matrix(c(4, 2, 8, 5), nrow=2, ncol=2, byrow=TRUE)
C = matrix(c(1, 2, 2, 4), nrow=2, ncol=2, byrow=TRUE)
AB = A %*% B
AB.t = t(AB)
A.t = t(A)
B.t = t(B)
B.tA.t = B.t %*% A.t
identical(AB.t, B.tA.t)
det(AB)
AB.inv = solve(AB)
A.inv = solve(A)
B.inv = solve(B)
B.invA.inv = B.inv %*% A.inv
identical(AB.inv, B.invA.inv)
B.inv-A.inv = B.inv %*% A.inv
B.inv_A.inv = B.inv %*% A.inv
A = matrix(c(3, 1, 2, 2), nrow=2, ncol=2, byrow=TRUE)
B = matrix(c(4, 2, 8, 5), nrow=2, ncol=2, byrow=TRUE)
C = matrix(c(1, 2, 2, 4), nrow=2, ncol=2, byrow=TRUE)
AB = A %*% B
AB.t = t(AB)
A.t = t(A)
B.t = t(B)
B.t_A.t = B.t %*% A.t
identical(AB.t, B.tA.t)
identical(AB.t, B.t_A.t)
det(AB)
AB.inv = solve(AB)
A.inv = solve(A)
B.inv = solve(B)
B.inv_A.inv = B.inv %*% A.inv
identical(AB.inv, B.invA.inv)
identical(AB.inv, B.inv_A.inv)
A
A.inv
B
AB.inv
B.inv_A.inv
identical(AB.inv, B.inv_A.inv)
qr(A)
A
qr(A)$rank
qr(B)$rank
qr(C)$rank
qr(C)
diag(A)
diag(A+B)
sum(diag(A+B))
sum(diag(A)) + sum(diag(B))
all.equal(sum(diag(A+B)), sum(diag(A)) + sum(diag(B))
all.equal(sum(diag(A+B)), sum(diag(A)) + sum(diag(B)))
all.equal(sum(diag(A+B)), sum(diag(A))+sum(diag(B)))
sum(diag(AB))
sum(diag(BA))
BA = B %*% A
BA
sum(diag(BA))
sum(diag(AB))
all.equal(sum(diag(AB)), sum(diag(BA)))
eigen(A)
eigen(A)$values
eigen(A)$values[1]
eigen(A)$values[2]
eigen(A)$values[1]
A - eigen(A)$values[1] * diag(2)
det(A - eigen(A)$values[1] * diag(2))
dim(A)
det(A - eigen(A)$values[1] * diag(2))
det(A - eigen(A)$values[2] * diag(2))
eigen(A)[,1]
eigen(A)$vector[,1]
norm(eigen(A)$vector[,1], 2)
norm(eigen(A)$vector[,1], "2")
?norm
norm(eigen(A)$vector[,1], type="2")
norm(eigen(A)$vector[,1], type="1")
norm(eigen(A)$vector[,1], type="2")
eigen(A)$vector[,1], type="2"
eigen(A)$vector[,1]
norm(eigen(A)$vector[,2], type="2")
eigen(A)
eigen(C)
# |A-λI|=0の確認
det(C - eigen(C)$values[1] * diag(2))
# 固有値ベクトルの長さの確認
norm(eigen(C)$vector[,1], type="2")
norm(eigen(C)$vector[,2], type="2")
T = eigen(C)$vectors
T
T.t = t(T)
T.t
T.t %*% C %*% T
round(T.t %*% C %*% T, 3)
eigen(C)
T
T[, 1]
t(T[, 1]) %*% T[, 1]
t(T) %*% T
round(t(T) %*% T, 3)
round(T.t %*% C %*% T, 3)
round(t(T) %*% T, 3)
AB
AB.t
AB.inv
A.t.inv
A.t.inv = solve(A.t)
A.inv.t = t(A.inv)
identical(A.t.inv, A.inv.t)
A.t.inv
det(AB)
det(t(A))
qr(A)$rank
qr(B)$rank
qr(C)$rank
sum(diag(A)) + sum(diag(B))
BA = B %*% A
sum(diag(BA))
eigen(A)
eigen(C)
plot(y ~ x)                           # 散布図を描く
x = c(2.2, 4.1, 5.5, 1.9, 3.4, 2.6, 4.2, 3.7, 4.9, 3.2)
y = c(71, 81, 86, 72, 77, 73, 80, 81, 85, 74)
plot(y ~ x)                           # 散布図を描く
plot(y~x)                           # 散布図を描く
result = lm(y ~ x)                  # 回帰分析を行う
abline(result)                                               # 推定回帰直線を描く
summary(result)
